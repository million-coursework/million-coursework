from sklearn.feature_extraction.text import TfidfVectorizer

import operator

titles = ["COMP1100", "COMP1110", "COMP2100", "COMP2120", "COMP2310", "FINM1001", "STAT1003", "PHYS1101", "CHEM1101", "COMP4670", "COMP3620"]

texts = ["This course is the first of three core computer science courses on programming. It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development. Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms. The course covers functional programming in depth, developing the core idea of functions operating on data structures.  Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions.  Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams. The functional paradigm demonstrates elegant solutions to many programming problems. The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences. Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects. The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree. These include distributed software revision control systems. The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience. Upon successful completion of this course, students will be able to: Apply fundamental programming concepts, using a functional programming language, to solve simple problems. Understand basic types and the benefits of static typing. Distinguish language definition from implementation, syntax and parsing from semantics and evaluation. Describe, understand and evolve programs, via documentation, testing, and debugging. Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition. Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming). Describe and apply alternative computational paradigms to simple problems. Understand the legal context for protection of software as intellectual property.",
         "This course introduces students to the fundamentals of software development with a substantial group software project at its center. Major foci are data structures, object oriented programming, and an introduction to software engineering. Students will extend their understanding of software productivity tools, using revision control for group work, and be introduced to test-driven development as an integral part of software construction. Students will be introduced to an industrial strength object oriented programming language, extending their understanding of the imperative programming paradigm with a solid grounding in object oriented programming.  Inheritance, polymorphism, and parametric types are taught, as well as concepts such as boxing and auto boxing. The important role of standard libraries and their collection types will be emphasized.  GUI programming will be introduced. The course includes a deeper treatment of data structures, using hash tables, trees and lists, which are used to provide concrete implementations of abstract library collection types. The theory of data structures and their time and space complexity will thus be tied to the practice of using standard collections such as those offered by object oriented languages. The foundations of software engineering including: major development paradigms (such as big plan up front, agile, and formal methods), risk are introduced. The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience. Upon completion of this course, the student will be able to: Apply fundamental programming concepts, using an object oriented programming language, to solve substantial problems. Understand basic types and the benefits of static typing for object oriented programs. Distinguish language definition from implementation, syntax and parsing from semantics and evaluation, understand how program state maps to memory (globals, local, heap), and understand the implications of heap reachability for memory management. Develop, understand, test, and evolve substantial programs using a modern IDE, and associated configuration tools; understand common coding errors and how to avoid them; practice fundamental defensive programming; perform individual and team program reviews; use established design principles to organize a software system. Use, implement, and evaluate fundamental data structures and associated algorithms;  create, implement, debug, and evaluate algorithms for solving substantial problems, including recursively, using divide-and-conquer, and via decomposition; implement an abstract data type. Apply basic algorithmic analysis to simple algorithms; use appropriate algorithmic approaches to solve problems (brute-force, divide-and-conquer, recursive backtracking, heuristic). Understand the basics of event-driven programming, and its use in constructing GUIs. Deliver and evaluate basic technical documents, presentations, and group interactions, using appropriate tools",
         "This course continues to build on topics taught in the previous two courses. It focuses on construction of medium scale programs, using design patterns and tools that are used in the software development process. Students will gain further experience with industry standard revision control and integrated development environment (IDE) tools. Students will learn appropriate application of programming abstractions they have learned in previous courses to the structuring of medium scale software: inheritance, generic types, polymorphism, procedural abstraction, and abstract recursive data structures (including abstract syntax trees as a program representation, and tools that manipulate them). The course also covers more advanced data structures, such as priority queues, B-trees, red-black trees, and AVL trees, and deepens understanding of appropriate algorithmic strategies. The course also treats intellectual property considerations in software development and deployment. Upon completion of this course, the student will be able to: Apply fundamental programming concepts for medium scale programs. Understand basic types and the benefits of static typing, with understanding of generics, subtyping, and overloading, and their roles in structuring programs. Map programming language abstractions through to execution environment; use non-source (text) internal representations of programs (e.g., abstract syntax trees); sketch low-level run-time representations of core language constructs (objects and closures). Describe contractual specifications, analyse documentation and specifications against other’s code, develop, understand, test, and evolve substantial programs using a modern IDE, and associated configuration tools; explain the importance of correctness for quality software; understand common coding errors and how to avoid them; practice fundamental defensive programming; understand principles of secure design. Use, implement, and evaluate more advanced data structures and associated algorithms; discuss factors other than computational efficiency for evaluating software; create, implement, debug, and evaluate algorithms for solving problems, including recursively, using divide-and-conquer, and via decomposition; implement an abstract data type; analyse design and implementation alternatives. Apply basic algorithmic analysis to simple algorithms; use big-O notation formally, upper lower, and expected case bounds; use and solve recurrence relations; use appropriate algorithmic approaches to solve problems (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming, branch-and-bound). Explain how system components contribute to performance; understand Amdahl’s law and its limitations; design and conduct performance experiments; use software tools to profile and measure program performance. Understand, apply, and analyse state and state machines in expressing computations. Understand fundamental concepts of GUIs and user interfaces; understand the basics of modeling and simulation. Contrast the concepts of copyright, patenting, and trademarks as mechanisms for protecting intellectual property, within the legal context for these mechanisms;  understand, analyse, and evaluate ethical/social tradeoffs in technical decisions, evaluating stakeholder positions",
         "Real-world software development is a dynamically complex activity involving uncertainty, people, technology and processes interacting within a similarly complex environment of clients, users and other stakeholders as well as evolving technological, physical, social, legal, ethical and other constraints. This course will empower students with the ability and confidence necessary to exercise critical thinking and professional judgment to select and apply appropriate knowledge, practices and tools to the development of non-trivial software systems within such complex environments. This will be achieved by first introducing students to key ideas and tools for dealing with complexity and uncertainty including Design Thinking. We will then build on previous programming and architecture courses to deepen and broaden student knowledge and understanding of the practices and tools used to build software systems within complex environments. We will use examples of real-time, distributed, web-based, high-integrity, games and other types of projects from local industry, published case studies and past software engineering student projects, to develop an understanding of when and why particular practices and tools are appropriate and when they are not. Students will also learn how practices and tools can be adapted to suit specific project needs and contexts. Knowledge, practices and tools considered in this course will cover process models, requirements engineering, design, modelling, construction, verification and validation, human-computer interaction, professional ethics, teamwork and social context. Upon completion of this course, the student will be able to: Demonstrate an ability to use knowledge, tools and practices relating to the following aspects of software engineering: a. Requirements b. Design c. Construction d. Verification & Validation e. Evolution f. Reliability g. Human Computer Interaction. Demonstrate familiarity with Complexity and Uncertainty. Demonstrate familiarity with approaches for dealing with complexity and uncertainty, including Systems Thinking and Design Thinking. Demonstrate an understanding that software development is a complex activity conducted within a complex socio-technical environment. Demonstrate the ability to use professional judgment to select and apply appropriate knowledge, practices and tools to the development of non-trivial software systems within complex and uncertain environments taking into account social, ethical and sustainability concerns. Demonstrate how practices and tools can be adapted to suit specific project needs and contexts.",
         "This course is based on the foundations set by the previous course on computer organisation. It expands particularly into all forms of concurrent programming including aspects of massively parallel programming. This course introduces all basic mechanisms to analyse, design, and manage concurrent, single computer-node (multicore) as well as distributed applications (e.g. as performance or dependability enhancements). Following on from the previous course, the fields of operating systems and networking will also be expanded on. On the operating system side aspects of security, scheduling algorithms and memory management are discussed. More specific networking aspects follow on from message passing as a core concurrency construct. These include the basics of routing and dependable protocols. Upon completion of this course, the student will be able to: Model, design and program concurrent systems. Select appropriate modeling techniques, tools and mechanisms to solve a range of problems in concurrent and distributed systems. This includes the appropriate programming language and runtime environment for the task at hand. Analyse and debug concurrent programs. Understand the aspects of an operating system concerning scheduling, protection and memory management. Employ message passing locally and over networks to construct distributed systems Distinguish as well as connect conceptual concurrency with physical parallelism at all levels of a distributed system. Identify core aspects of operating systems and networks irrespective of the specific system at hand.",
         "Foundations of Finance is designed to familiarise students with the components of the financial system as well as to introduce them to the three basic ideas underpinning finance, namely the time value of money, diversification and arbitrage.  In doing so, the course provides students with introductory exposure to financial transactions, institutions and markets including debt, equity, foreign exchange and derivative markets and the instruments traded therein. It also provides students with a solid foundation for later studies in finance. On satisfying the requirements for this course, students will have the knowledge and skills to: Understand financial transactions, institutions and markets, including money markets, stock markets, foreign exchange, derivatives markets and contracts.Understand the ideas behind the time value of money and be able to calculate the value of cash flows relating to a number of financial instruments. Understand the concept of diversification, including the risk and return relationship and have the ability to calculate optimal weights for a portfolio comprising of two financial assets. Understand concepts of arbitrage, and utilise derivatives for risk management purposes.",
         "This course introduces students to the philosophy and methods of modern statistical data analysis and inference, with a particular focus on applications to the life sciences. Why and how to use: tables to organise and summarise data; graphics to present statistical information; measures of location and spread for univariate distributions. Concepts of randomness, uncertainty, random variables, probability distributions (including uniform, binomial, normal), and sampling distributions and how to apply these for inference from small and large samples through: confidence intervals; hypothesis testing in one and two sample cases; p-values; linear regression models and analysis of variance. Examples and applications will be drawn extensively from the life sciences, particularly Biology. The course has a strong emphasis on computing and graphical methods, and uses a variety of real-world problems to motivate the theory and methods required for carrying out statistical data analysis. This course makes extensive use of R statistical analysis package interfaced through R Studio. Upon successful completion of the requirements for this course, students should have the knowledge and skills to: Summarise and graph data appropriately; Work with random variables and probability distributions and understand the rationale behind them; Understand and use the normal distribution appropriately; Identify when and how to carry out basic statistical inference including confidence intervals, hypothesis testing and regression and ANOVA; and, Identify contexts in which a method may be appropriate (e.g. using a large sample method when sample size is small).",
         "Why can't we build practical flying cars? How do stars explode? Why do mouse hearts beat so fast? Could you stop a cyclone by dropping an atomic bomb on it? Why do smartphone batteries run flat so fast? If you build yourself a super-hero suit, how long could you fight criminals before your batteries go flat? Could the Death Star really destroy a planet? In this course, we will use physics to answer these questions, and many more like them. The course introduces the key ideas of modern physics, ranging from quantum mechanics to astrophysics, and from electromagnetic waves to thermodynamics. Using these concepts, we show how physics allows us to come up with innovative solutions to a wide range of modern-day problems. The course focusses on problem-solving: using your knowledge of physics in complicated real-world contexts, using data analysis, modelling, laboratory analysis and back-of-the-envelope estimation to get answers to seemingly impossible problems. More advanced (honours pathway) options are available in this course. Upon successful completion of this course, students will have the knowledge and skills to: Construct and use appropriate physical models for a wide range of physical situations, including computer modeling, and explain their limitations. Quickly estimate order-of-magnitude values for a wide range of physical quantities. Analyse and interpret uncertain data, including computer analysis. Become proficient with vectors and vector fields. Estimate the systematic and random uncertainties in both experimental and theoretical situations. Construct and analyse DC and AC circuits using a breadboard, multimeter and oscilloscope",
         "The following syllabus provides a general guide to the topics to be discussed: Atomic structure and bonding: electronic structure of atoms, quantum numbers, orbitals and energy levels, filling sequence, periodicity of atomic properties, octet 'rule', chemical bonds - ionic, covalent - energetics, H-bonds, Lewis structures, shapes of molecules, VSEPR theory, valence bond theory, hybridisation, resonance, molecular orbital theory of simple homonuclear diatomic molecules. Equilibrium: Haber process as example of the Law of mass action, equilibrium constants, Kc and Kp, Le Chatelier's principle, reaction quotient, endo- and exo-thermic reactions. Acids/bases and aqueous equilibria: classical, Lowry-Brønsted, and Lewis definitions, pH of aqueous solutions, strengths of acids and bases - Ka and Kb, titration curves, buffers, extent of hydrolysis - weak acids/bases, solubility products. Introductory thermodynamics: Energy - different forms, kinetic and potential, heat and work, the First Law of Thermodynamics, conservation of energy, internal energy and enthalpy, Hess' Law, state functions, standard states, calorimetry. Electrochemistry: redox reactions, half-cell reactions and balancing equations, oxidation states, Voltaic cells, electrodes, electrode potentials, electromotive force and the free energy of cell reactions, Nernst equation. Advanced thermodynamics: entropy, Second and Third Laws of Thermodynamics, free energy, equilibrium, spontaneous processes, equilibrium constants - calculations, extent of reaction. Organic structure, isomerism & reactivity: carbon hybridization, functional groups, nomenclature, 3D chemistry, conformations, isomerism, biological and synthetic polymers - for example, polyamides and polysaccharides. Laboratory: Exercises illustrating the simpler principles of analytical, inorganic, organic and physical chemistry. The apparatus used in the course is supplied by the Research School of Chemistry. Attendance at laboratory classes is compulsory. Replacement of 12 tutorials with 12 additional lectures at a more advanced level. The HPO is designed for students with a strong interest in chemistry from school, Science Summer School, Olympiad or equivalent. It is expected that all students in the PhB, or Honours degree programs enrolled in CHEM1101 will complete the HPO. On satisfying the requirements of this course, students will have the knowledge and skills to: Demonstrate an understanding of the electronic structure of an atom and the concept of chemical bonding and be able to interpret the relationships between them. Demonstrate an understanding of the laws of thermodynamics, heat changes in reactions and entropy.  Be able to explain whether a reaction is spontaneous.Demonstrate an understanding of chemical equilibria, acids and bases and the processes occurring in solution.  Be able to perform quantitative calculations. Be able to interpret a developed thin layer chromatogram. Be able to demonstrate an insight and understanding into the bonding and structure of a variety of simple organic molecules, including isomerism and stereochemistry. Be able to demonstrate the use of chemical nomenclature and the knowledge of the classification, properties and reactions of a wide variety of organic compounds according to the functional groups they contain. Recognise the importance of chemistry in the biological sciences and society at large . Be able to apply chemical concepts to the understanding of biological structures and processes. Demonstrate the ability to perform safe laboratory manipulations and to manipulate glassware.  Be able to perform volumetric analysis and chemical synthesis following a prescribed procedure.",
         "This course provides a broad but thorough introduction to the methods and practice of statistical machine learning. Topics covered will include Bayesian inference and maximum likelihood modeling; regression, classification, density estimation, clustering, principal and independent component analysis; parametric, semi-parametric, and non-parametric models; basis functions, neural networks, kernel methods, and graphical models; deterministic and stochastic optimisation; overfitting, regularisation, and validation. On satisfying the requirements of this course, students will have the knowledge and skills to: Describe a number of models for supervised, unsupervised, and reinforcement machine learning. Assess the strength and weakness of each of these models. Interpret the mathematical equations from Linear Algebra, Statistics, and Probability Theory used in these machine learning models. Implement efficient machine learning algorithms on a computer. Design test procedures in order to evaluate a model. Combine several models in order to gain better results. Make choices for a model for new machine learning tasks based on reasoned argument",
         "Artificial intelligence is the science that studies and develops methods of making computers more /intelligent/. The focus of this course is on core AI techniques for search, knowledge representation and reasoning, planning, and designing intelligent agents. The course also aims to give an overview of the historical, philosophical, and logical foundations of AI. After completing this course, students should be able to: Identify problems that are amenable to solution by AI methods, and which AI methods may be suited to solving a given problem. Formalise a given problem in the language/framework of different AI methods (e.g., as a search problem, as a constraint satisfaction problem, as a planning problem, etc). Implement basic AI algorithms (e.g., standard search or constraint propagation algorithms). Design and perform an empirical evaluation of different algorithms on a problem formalisation, and state the conclusions that the evaluation supports."]

tf = TfidfVectorizer(analyzer='word', ngram_range=(1, 3), min_df=0, stop_words='english', max_df=0.7)

tfidf_matrix = tf.fit_transform(texts)
feature_names = tf.get_feature_names()
dense = tfidf_matrix.todense()

tags = {}

for idx in range(len(titles)):
    print()
    print(titles[idx])
    print()
    episode = dense[idx].tolist()[0]
    phrase_scores = [pair for pair in zip(range(0, len(episode)), episode) if pair[1] > 0]

    z = sorted(phrase_scores, key=lambda t: t[1] * -1)[:10]
    indices = [x for (x, s) in z]
    features = []
    for i, s in z:
        features.append((feature_names[i], s))
        if feature_names[i] not in tags:
            tags[feature_names[i]] = s
        else:
            tags[feature_names[i]] += s

    # if individual words from tuples are present in the list, remove them
#    for phrase in features:
#        if " " in phrase:
#            phrase_words = phrase.split(" ")
#            for word in phrase_words:
#                if (word, _) in features:
#                    features.remove((word, x))

    for i, z in features:
        print(i, z)
print(tags['programming'])
most_popular_tag = max(tags.items(), key=operator.itemgetter(1))[0]

